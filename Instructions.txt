Orion Agent 

Description
Orion Agent is an in-process AI companion that converts natural–language requests into MATLAB® scripts and Simulink® models, executes them, inspects results, and iterates—without any GUI-level mouse automation.
It achieves this by exposing a curated set of programmatic “tools” (functions) to a Large-Language Model (LLM). A lightweight ReAct loop stored in memory decides which tool to call next, receives structured feedback (block handles, simulation outputs, error objects), and plans subsequent actions until the user’s goal is met.
Build Orion Agent, an in-process AI assistant that lives inside a licensed MATLAB + Simulink session, interprets natural-language tasks through a large-language model (LLM), and executes them programmatically by calling documented MathWorks APIs. Orion never drives the GUI with mouse clicks; it manipulates models through add_block, add_line, set_param, sim, the MATLAB Desktop Editor API, and other stable interfaces.
________________________________________
2 Project layout
orion-ai-agent-mab/
│
├── +agent/                  % core decision loop
│   ├── Agent.m              % ReAct controller; owns chat history
│   ├── ToolBox.m            % registers callable tools
│   └── utils/
│       └── redactErrors.m   % strips stack traces before LLM sees them
│
├── +tools/                  % thin wrappers around MATLAB/Simulink APIs
│   ├── run_code.m           % evalc wrapper for arbitrary MATLAB code
│   ├── new_model.m          % new_system + open_system
│   ├── add_block_safe.m     % add_block wrapper (makes name unique) :contentReference[oaicite:0]{index=0}
│   ├── connect.m            % add_line; path syntax described in  :contentReference[oaicite:1]{index=1}
│   ├── arrange.m            % Simulink.BlockDiagram.arrangeSystem
│   ├── sim_model.m          % out = sim(mdl,'ReturnWorkspaceOutputs','on');
│   ├── open_editor.m        % matlab.desktop.editor.openDocument
│   └── doc_search.m         % find_system / web search of MathWorks help
│
├── +llm/
│   ├── callGPT.m            % webwrite → OpenAI or local Llama
│   └── promptTemplates.m    % System & few-shot templates
│
├── app/
│   └── AgentChat.mlapp      % App Designer UI: chat pane + live model PNG
│
└── tests/
    └── t_basic.m            % ensures each tool works on clean MATLAB
________________________________________
3 APIs include others
Capability	MATLAB/Simulink call	Doc
Insert block programmatically	add_block(source,dest) → returns handle	MathWorks - Maker of MATLAB and Simulink

Connect ports	add_line(model,src,dst)	MathWorks

Clean diagram layout	Simulink.BlockDiagram.arrangeSystem(model)	MathWorks - Maker of MATLAB and Simulink

Query / set parameters	get_param, set_param, Simulink.Mask APIs	MathWorks - Maker of MATLAB and SimulinkMathWorks - Maker of MATLAB and Simulink

Add annotations / notes	add_block('built-in/Note', …)	MathWorks - Maker of MATLAB and Simulink

Discover library paths	find_system('SearchDepth',0,'Name',query)	MathWorks - Maker of MATLAB and Simulink

Build and run simulation	sim(model,'ReturnWorkspaceOutputs','on')	MATLAB Simulink doc
Evaluate free-form code	evalc(codeStr) (captured console)	MATLAB language doc
These documented calls are stable across releases, unlike pixel-level GUI automation.

Layer	Technology	Purpose
LLM	GPT-4o (OpenAI REST) or local Llama 3 served over HTTP	reasoning + code generation
MATLAB engine	matlab.engine for Python only if the agent is launched outside MATLAB; otherwise call APIs directly	invokes MATLAB commands, opens/edits models
Simulink programmatic API	add_block, add_line, Simulink.BlockDiagram.arrangeSystem, sim, find_system, set_param	create & mutate diagrams 
Desktop Editor API	matlab.desktop.editor.openDocument, save, insertText	open/modify .m, .mlx files programmatically
HTTP client	webwrite, webread	talk to the LLM endpoint
UI	App Designer (AgentChat.mlapp)	chat pane + live PNG preview via Simulink.BlockDiagram.createSnapshot
Tests	matlab.unittest	regression and acceptance criteria
Version control	Git	track code and generated models

________________________________________
4 Build plan (step-by-step)
Step	Action	Outcome
1	Clone the repo into a regular MATLAB project (so paths auto-load).	orion-ai-agent-mab added to MATLAB path.
2	Open AgentChat.mlapp and press Run. The UI creates an agent.Agent instance internally.	Chat window appears.
3	Configure the LLM: set OPENAI_API_KEY (or change callGPT.m to your local endpoint).	External reasoning engine reachable.
4	Unit-test tools: runtests('tests').	Confirms that every wrapper (add_block_safe, connect, etc.) works on your MATLAB version.
5	Interact: type “Create a model with a Sine Wave feeding a Scope and simulate for 1 s.”	Orion Agent executes: new_model → add_block_safe ×2 → connect → arrange → sim_model, returns PNG + first samples.
________________________________________
5 Runtime flow inside Agent.m
mermaid

graph TD
    U(User Prompt) --> P[PromptBuilder]
    P -->|System+History| L[callGPT]
    L -->|JSON: {tool,args}| D[Dispatcher]
    D -->|function handle| T[+tools/*]
    T --> R[Result (string, struct, PNG)]
    R --> H[history update]
    H --> P
    R --> UI[AgentChat pane]
•	PromptBuilder (in promptTemplates.m) merges user text, truncated history, and the tool list.
•	Dispatcher verifies the requested tool exists in ToolBox; if not, returns an error object for the LLM to reconsider (ReAct pattern).
•	History keeps alternating Thought → Action → Observation triples, enabling multi-step planning.
________________________________________
6 Extensibility hooks
•	Add a new tool: drop my_tool.m in +tools/, add its handle in ToolBox.register().
•	Swap LLM: edit llm/callGPT.m. Response must stay JSON-parseable.
•	CI regression: integrate tests/ into GitHub Actions using the MathWorks-hosted runner (matlab-actions/run-tests).
•	Vision upgrade: inside arrange.m, call createSnapshot and send the PNG to GPT-4o-Vision for spatial feedback.
________________________________________
7 Safety guidelines
•	Wrap every tool call in try/catch; pipe the MException through utils/redactErrors to avoid leaking file paths.
•	Hard-limit model size: e.g., raise a warning if numel(find_system(mdl,'Type','block')) > 1000.
•	Use Simulink.BlockDiagram.validate after structural edits to guarantee the diagram compiles before simulation.

